# M5StickC-Plus Display Graphics Library Specification

## Hardware Overview and Driver Setup
The M5StickC-Plus features a built-in 1.14-inch TFT color display driven by an ST7789V2 controller, with a native resolution of 135×240 pixels (240 columns by 135 rows). We will use MicroPython’s generic ESP32 display driver for ST7789 to interface with this screen. On the M5StickC-Plus, the TFT is connected via SPI (at up to 20 MHz) and requires enabling the on-board power control and backlight pins (GPIO4 and GPIO27) before use. The driver is initialized as:

spi = machine.SPI(1, baudrate=20_000_000, polarity=1, sck=Pin(13), mosi=Pin(15))
display = ST7789(spi, 135, 240, reset=Pin(12), dc=Pin(14), cs=Pin(5))
display.init()  # initialize TFT (if using C-optimized driver)
This sets up the ST7789 driver with the full 135×240 resolution. The display will be used in its portrait orientation by default (135 pixels wide, 240 tall), unless rotated via the driver. The driver and display support a 16-bit color mode (RGB565) natively, which we will leverage for rich color graphics. (Color values are provided as 16-bit integers 0–65535 in RGB565 format.)

## Color Depth and Resolution
We will support the panel’s full 135×240 resolution at (ideally) its native color depth. The ST7789 typically operates in 16-bit color (5-6-5 bits for R-G-B), yielding 65,536 colors. Using 16-bit color ensures that loaded images retain reasonable color fidelity. The minimum acceptable color depth is 8-bit (256 colors) as mentioned, but MicroPython’s frame buffer API does not provide a built-in 256-color indexed mode – it supports either grayscale or full 16-bit color for RGB displays. Therefore, our library will use 16-bit RGB565 color throughout, which is the natural format for the M5StickC-Plus display. This gives us 65k colors and matches what the ST7789 controller expects, avoiding extra color conversion overhead at draw time.

Memory footprint: At full resolution and 16-bit depth, a single full-frame buffer requires:

135 × 240 × 2 bytes ≈ 64,800 bytes (~63.3 KB) of RAM for pixel data.

This is within the device’s limits, but significant – the ESP32’s available MicroPython heap is on the order of ~80–100 KB for user objects in practice. We must be mindful of this usage, as outlined in Memory Constraints below.

## Framebuffer and Full-Screen Updates
To manage rendering efficiently and avoid flicker, the library will use frame buffering (off-screen drawing). We allocate a off-screen FrameBuffer covering the entire 135×240 screen. All drawing operations (text, lines, images, etc.) will render into this memory buffer first. Then, we update the actual display in one burst – effectively one full-screen blit – when a frame is ready to be shown.

Using a frame buffer allows preparing the next screen “offline” and then pushing it to the LCD in one SPI transaction. This prevents visible tearing or partial updates. MicroPython’s graphics API supports this kind of bit-block transfer: once our image/frame is prepared in a buffer, we can call the driver’s blit_buffer() (or an equivalent method) to copy the pixels to the TFT in one go. The ST7789 MicroPython driver (based on devbis’s st7789py_mpy) indeed provides a blit_buffer(buffer, x, y, w, h) function to update a region from a pixel buffer. We will typically use it to update the entire screen at once (w=135, h=240) for a full frame refresh.

Rationale: MicroPython doesn’t have a built-in image-drawing API, but it does support fast memory-to-screen blitting. By preparing an entire frame in RAM and then blasting it to the display, we eliminate per-pixel overhead during the visible update. The SPI transfer of ~64 KB at 20 MHz is only ~25 ms, so the main cost is building the frame in Python. This design ensures the user sees the interface update one full screen at a time (no slow scanline drawing). If needed, double-buffering (alternating between two frame buffers) could be used to prepare one frame while another is displayed, but given memory constraints we plan to use a single buffer and update during times when the display can be refreshed without tearing (such as between UI screens or on VSync if available).

## Image Format Support and Rendering
To display arbitrary images, the library will include support for reading an image file from the device’s flash filesystem and rendering it to the screen buffer. The M5StickC-Plus running MicroPython has an internal flash (4 MB) used as a storage (e.g. accessible via /flash or root), so we can save image files there (via USB or OTA) and load them at runtime. We aim to support at least one common standard image format that is simple to decode on-device. The recommended choice is BMP (Bitmap) in an uncompressed form:

BMP (24-bit color) – This format stores raw pixel color values and is straightforward to parse in MicroPython. Many image editors (Photoshop, GIMP, etc.) can export 24-bit BMP easily. We will specifically support 24-bit RGB888 BMP files with no compression, as these are the simplest: each pixel is represented by 3 bytes (often in BGR order in BMP).

BMP decoding approach: Our library will implement a BMP file reader in Python to retrieve image pixels. The procedure: open the file from flash (open('image.bmp','rb')), parse the BMP header to get image width, height, and bit depth. We’ll assume the image dimensions will match (or be smaller than) 135×240 for simplicity. We then read the pixel data and populate the frame buffer:

Reading strategy: Rather than loading the entire image file into memory (which could be ~97 KB for 135×240×3, potentially exhausting the heap), we will read it line by line (row by row). The BMP format typically stores pixels bottom-up, so we may need to seek to the start of the bottom row and read upwards. For each row, read 3×135 bytes from the file, convert each 24-bit pixel to 16-bit RGB565, and write it into the corresponding row in the frame buffer. This incremental reading keeps memory usage low (only a few hundred bytes buffer for a row). Once all rows are processed, the frame buffer contains the full image in 16-bit format. Finally, we call the display update (blit) to push the completed image to the screen in one shot.

This method ensures we “display in one go” – the user won’t see a partial image drawing. The conversion loop from 24-bit to 16-bit will be implemented in C-friendly Python (using bit shifts or possibly ustruct) for efficiency. For example, if a pixel’s bytes are (B, G, R), we form an RGB565 word as ((R&0xF8)<<8) | ((G&0xFC)<<3) | (B>>3).

Memory considerations for images: By streaming the file row-wise, we never hold the full 90+ KB of 24-bit pixel data in RAM at once. We only need the 64 KB frame buffer and a small buffer for one line. This approach is crucial on MicroPython, since attempting to load a full-screen image into RAM can fail with MemoryError on devices like the Pico or ESP32. If even 64 KB proves high (in extreme cases), one could split the image into smaller tiles and load each tile sequentially, but for 135×240 we expect the single-buffer approach to work. (Should memory be very tight, an alternative is to use a lower bit depth buffer and a palette, but that adds complexity and reduces quality, so we stick to 16-bit color.)

Other formats: We focus on BMP for simplicity. Formats like JPEG or PNG are more complex to decode – they require decompression algorithms not present in standard MicroPython. While it’s technically possible (for example, optimized drivers have hooks for JPEG decoding with sufficient RAM, and PNG line-by-line drawing), implementing these in pure Python would be heavy and likely exceed memory/time constraints for a “small” library. GIF (for simple animations or icons) is also non-trivial due to LZW compression and palette handling. Therefore, our library will not initially support JPEG/PNG/GIF to keep it lightweight. Instead, users can convert images to BMP offline. (If needed, a future extension could integrate a MicroPython C module or a decoder for JPEG/PNG, but this trade-off goes beyond our current scope.)

## Drawing Primitives (Text and Shapes)
Besides image blitting, the graphics library will offer basic drawing functions for UI elements and graphics, rendered into the frame buffer:

Pixels: Set an individual pixel at (x, y) to a given color. This is the lowest-level primitive (e.g. draw_pixel(x, y, color)), and can be used internally by other shape routines. The color is a 16-bit int in RGB565 format (the library may provide a helper to convert 8-bit RGB components to a 16-bit value). The underlying driver’s pixel() method or frame buffer’s pixel access will be used.

Lines: Draw a line between two points (x1,y1) to (x2,y2) with 1-pixel thickness. We will likely utilize Bresenham’s line algorithm or simply use MicroPython’s built-in framebuf.line() method for efficiency. The MicroPython FrameBuffer class supports drawing straight lines in any direction given start and end coordinates, so we can leverage that on our buffer. Horizontal and vertical lines (hline/vline) could also be optimized if needed (the framebuf has those as well).

Rectangles: Draw rectangles given top-left (x,y), width, height. We will support both outlined rectangles and filled rectangles. This can be done via the frame buffer’s rect() method for outlines and fill_rect() (or rect(..., fill=True)) for filled areas. These are efficient C implementations in the MicroPython framebuf. For example, fbuf.rect(x, y, w, h, color) draws a 1-pixel border, and with a fill flag it will fill it.

Circles/Ellipses: We plan basic circle drawing for simple graphics. A circle is a special case of an ellipse. If available, we can use FrameBuffer.ellipse(x, y, rx, ry, color, fill=False) with rx == ry to draw a circle. (MicroPython’s latest framebuf API does provide an ellipse function where equal radii produce a circle.) If that is not available in the user’s firmware, we can implement a midpoint circle algorithm in Python as a fallback. Filled circles (disks) could be done by drawing many horizontal lines or using the ellipse fill parameter if supported.

Polygons: While not explicitly requested, the library could even support arbitrary polygons or triangles for advanced use. The MicroPython framebuf includes a poly() method for drawing a closed polygon from a list of vertices. We might not need this immediately, but it’s good to note that convex or concave polygons can be drawn (outline or filled) if needed for custom shapes.

Text: Rendering text is important for UI labels or readings. We will include a basic text drawing function, likely using the built-in 8×8 pixel font provided by MicroPython. The FrameBuffer.text(str, x, y, color) method can write a string to the buffer at given coordinates. Each character is rendered in a simple font (roughly ASCII, 8×8 pixels each) and cannot be scaled. This is a limitation – text will be quite small on the 1.14" display. For larger or nicer fonts, one would need to include a custom font bitmap. To keep the library simple, we will start with the default font. (Option: We could integrate larger fonts by storing font bitmaps in Python or using the ST7789 driver’s font support. The C-optimized ST7789 driver by Russ Hughes allows using converted TrueType fonts or BIOS fonts, but in a pure MicroPython context we might instead provide a way for the user to blit their own font images or use multiple 8×8 characters as a workaround for bigger text.)

Colors: For drawing primitives, the user can specify colors in an easy manner. We’ll provide a few predefined color constants (e.g. WHITE = 0xFFFF, BLACK = 0x0000, etc.), and/or an RGB565 helper. For example, a function color565(r,g,b) to pack 8-bit RGB into 16-bit (many drivers include such a helper). This allows using intuitive 0–255 color values when drawing text or shapes.

All these drawing operations write into our frame buffer (which is just a chunk of RAM). They do not instantly update the screen. After drawing, the display remains unchanged until we call the blit/refresh function. This way, you can draw multiple things (lines, text, etc.) for a composite screen and then update the LCD once at the end of your drawing routine. This design matches the “draw off-screen, then show” paradigm for flicker-free graphics.

Notably, we can choose to leverage the existing ST7789 driver’s methods for some of these operations. The MicroPython ST7789 driver (derived from devbis’ library) already supports fill(), pixel(), line(), rect(), text(), etc., implemented in C or optimized Python. For example, one can do display.text("Hello", x, y, color) directly with that driver (as shown in the M5StickC-Plus module example). However, drawing directly to the display one primitive at a time may cause flicker if multiple elements are drawn separately. Therefore, our library may instead create a framebuf.FrameBuffer object backed by a bytearray (size 64k) and draw into that using framebuf’s methods (which are C-accelerated). After composing the entire screen in the buffer, we flush it to the actual display with one call. This approach combines the convenience of the framebuf drawing API with the double-buffered update. It also means our library is not heavily tied to ST7789 – in theory the buffer could be sent to any similar RGB565 display.

## Memory Constraints and Optimization
Operating within the M5StickC-Plus’s memory limits is a key consideration for this graphics library. As mentioned, a full 16-bit frame buffer eats up ~64 KB of RAM. The ESP32 has 520 KB RAM, but under MicroPython a large portion is used by the runtime and heap fragmentation can occur. Empirically, around 80–100 KB might be free for user Python objects on a device like this. Allocating the frame buffer will take the majority of that, leaving perhaps ~20–30 KB for everything else (Python bytecode, stack, other data).

To ensure we don’t run out of memory or crash:

One-time Allocation: We will allocate the screen buffer once (at library init) and reuse it. Frequent allocate/free of a 64k buffer would fragment the heap quickly. By keeping a single persistent buffer (possibly as a global or static in the library), we avoid large heap churn. MicroPython’s garbage collector should handle other small objects, but we treat the frame buffer as essentially a static display memory.

Drawing in Place: All drawing functions modify the existing buffer in place. We avoid making copies of large data. For example, when drawing an image, we convert directly into the frame buffer rather than first building a separate full image array. When rendering text or shapes, the operations already work in place on the buffer. The use of the C-implemented framebuf methods (line, rect, etc.) also helps here – they operate efficiently on the buffer without creating Python objects per pixel.

Incremental Image Loading: As described, image files are loaded incrementally. We do not read an entire image file into a Python object (which could double the memory usage and risk failure). By handling one line at a time, we only use a few hundred extra bytes at a time. The BMP reader approach is explicitly designed “to read BMP files without requiring too much RAM”. If an image still approaches the heap limit (e.g., a full-screen 135×240 24-bit BMP ~97 KB plus 64 KB buffer might be borderline), we may need to reduce overhead (garbage collect before loading, etc.). In extreme cases, splitting the image into smaller sections (tiles) is a workaround – e.g. load and blit a 135×80 chunk three times to cover the screen. The BMP reader documentation suggests breaking large images into tiles to fit memory on RAM-limited targets. For our resolution, however, we expect to manage with careful streaming.

Frame Rate vs Complexity: Because our library is Python-based, complex drawing operations will be slower than in C. Redrawing the entire screen frequently (e.g. for animation) might be limited. For instance, reading and converting a 135×240 image in Python could take on the order of a few seconds on the ESP32 (one test on a similar 160×128 image took ~5.7 s on an MCU). Our focus is on static or infrequently updated screens (menus, sensor readings, etc.) rather than high-frame-rate animations. If we needed faster updates, we’d consider limiting the drawn area (partial updates) or using C extensions. The ST7789 driver itself can scroll or partial-blit efficiently, which we could expose for optimizations (e.g. updating only a small region of the screen if only that changed, to save time and power).

Garbage Collection: We will ensure that large allocations (like the frame buffer) are done at start, and if we ever allocate a big temporary buffer (we try not to), we’ll free it quickly. It’s wise to manually invoke gc.collect() after heavy image loads or a series of drawing operations, to clean up any fragmentation. The C driver notes that enabling GC is important when doing dynamic allocation of big buffers. In MicroPython, GC is usually automatic, but we may document the recommendation to call it if memory gets tight after many updates.

Use of Existing Optimized Modules: By leveraging MicroPython’s built-in primitives (framebuf, etc.), we get a lot of speed in C and save Python overhead. We also use micropython.const for color constants to avoid runtime overhead, and can mark performance-critical small functions with @micropython.native or @micropython.viper if needed to boost speed (at the cost of some extra code size). These steps help stay within both speed and memory budgets.

In summary, the design consciously trades a chunk of RAM (~64 KB) to enable full-resolution buffering and flicker-free updates. We’ll stay within the remaining memory by streaming file data and avoiding duplicate buffers. Testing will be done to confirm that a 135×240 image can indeed be loaded on the M5StickC-Plus without errors – if not, we will adjust (e.g. use a smaller offscreen buffer with 8-bit color and upconvert on the fly, or tile the rendering). But given the device specs, using the full 16-bit frame should be feasible.

## Utilizing Existing Drivers and Libraries
Where possible, we will build on existing drivers to minimize reinventing the wheel. The ST7789 MicroPython driver (e.g. the one by devbis, or the fork by Russhughes) already implements many of the low-level functions in C. Our library can either wrap that driver or integrate with it:

We use the driver’s initialization and low-level blit_buffer to send our frame buffer to the screen.

We can call the driver’s fill() method to quickly clear the screen (it fills the LCD with a color), though we also maintain our buffer so we’ll fill the buffer then push.

For text and shapes, if we attach the frame buffer to the driver (some drivers allow using the display as a frame buffer device) we might use driver methods. However, in our design we mostly use framebuf on a Python buffer, which is device-agnostic.

The existing driver (if using Russhughes’ version with fonts) can even support custom fonts, JPEG, PNG, etc. – we won’t enable those heavy features by default, but knowing they exist means advanced users could swap in that optimized firmware if they need to display a JPEG with limited RAM (it uses a streaming draw for JPEGs to avoid full decode in RAM). Our library aims to remain pure MicroPython for portability with the “generic ESP32 build”, so we aren’t requiring a custom firmware.

By using the standard MicroPython constructs (SPI, framebuf, file I/O), our solution stays within the MicroPython ecosystem. The filesystem on the M5StickC-Plus (LittleFS or FAT on internal flash) is used for image storage and retrieval, which the user can manage via USB or Wi-Fi. The library simply opens files from that system. No SD card is required (unless images are too large for internal flash, which is unlikely for small screens).

Summary of Features
Resolution & Color: Full 135×240 resolution, using 16-bit RGB565 color (65k colors) for vivid images. This meets the “at least 256-color” requirement by far (we provide much more color depth).

Frame Buffering: Off-screen frame buffer (≈64 KB) for constructing each screen. Entire frame pushed to display in one update, preventing flicker or tear.

Image Loading: Support for at least BMP 24-bit images – a simple and standard format that can be generated easily. The library will parse and convert BMP files from the device’s flash storage into the frame buffer, then display them in one go. This avoids complex codecs and keeps memory usage manageable. (User tip: save BMPs at 135×240 or smaller, 24-bit color, no compression for best results.)

Drawing Primitives: Functions to draw pixels, lines, rectangles (outline and filled), circles, and text onto the off-screen buffer. We leverage MicroPython’s framebuf methods for efficiency (e.g. line(), rect(), text() etc. are available and optimized in C). Text is drawn using an 8×8 pixel font by default; multiple text colors and basic background fill for text are supported (e.g. we can implement text with background by drawing a filled rect under the text, since the default font is monochrome). More advanced fonts or shapes can be added as needed (the infrastructure allows blitting small bitmaps, so icons or custom font glyphs can be drawn too).

Memory Management: The design fits in the M5StickC-Plus’s RAM by using a single static buffer and streaming image data. A full-screen buffer (~64 KB) is allocated once. Image decoding is done in chunks to avoid high memory peaks. We understand the ESP32’s memory limits and avoid operations that would exceed it. The library will document the approximate memory usage and advise users to refrain from creating many large Python objects alongside this graphics buffer.

Performance: While not designed for high-speed gaming, the library will handle typical UI refresh needs. Clearing the screen or drawing a few shapes and text can happen in a few tens of milliseconds (much of that being the SPI transfer). Loading a full image might take a second or two in Python, so it’s best for static screens or occasional image displays (e.g. showing a logo or photo). If performance needs increase, one can consider using the C-optimized ST7789 driver (which our library is compatible with) to accelerate certain operations.

By adhering to these specifications, we ensure the graphics library for the M5StickC-Plus is complete yet lightweight. It will allow developers to display full-screen graphics, text, and images in MicroPython with relative ease, all while respecting the device’s resource constraints. The use of standard formats and existing MicroPython facilities makes the solution maintainable and easy to integrate into projects.

Sources: The above design is informed by the M5StickC-Plus hardware specs, MicroPython’s documentation and drivers for frame buffers and ST7789 displays, as well as community insights on image handling in MicroPython and optimized driver capabilities. This ensures our approach is grounded in known good practices and will achieve the desired functionality.

